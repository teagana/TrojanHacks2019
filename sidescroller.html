<!DOCTYPE html>
<html>
<head>
	<title>side scroller</title>
	<style>
		/* PUT CSS CODE HERE */
		canvas {
			background: #eee;
		}
	</style>
</head>
<body>
	<canvas id="myCanvas" width="480" height="320"></canvas>
	
	<script>
		//PUT JAVASCRIPT CODE HERE
		var canvas = document.getElementById("myCanvas");
		var ctx = canvas.getContext("2d");
		var ballRadius = 10;
		var x = canvas.width/2;
		var y = canvas.height-20;
		var dx = -4;
		var dy = 1.5;
		var paddleHeight = 5;
		var paddleWidth = 400;
		var paddleX = (canvas.width-paddleWidth)/2;

		var rightPressed = false;
		var leftPressed = false;
		var upPressed = false;
		var inAir = false;
		var gravForce = 2;

		var brickRowCount = 5;
		var brickColumnCount = 3;
		var brickWidth = 75;
		var brickHeight = 20;
		var brickPadding = 10;
		var brickOffsetTop = 250;
		var brickOffsetLeft = 30;
		var score = 0;
		var lives = 3;

		var bricks = [];
		for(var c=0; c<brickColumnCount; c++) {
		  bricks[c] = [];
		  for(var r=0; r<brickRowCount; r++) {
		    bricks[c][r] = { x: 0, y: 0, status: 1, width: 50, height: 20 };
		  }
		}
		var obstacles = [];
		for(var c=0; c<50; c++) {
		  obstacles[c] = [];
		  obstacles[c]{ x: 0, y: 0, status: 1, width: 50, height: 20 };
		}

		//array of obstacles
		//if (xPos < 0), array[index].valid = 0
		//on draw, if random() return true, call spawn new obstacle
		//iterate through array, find first with valid = 0
		//spawn new rectange at canvas.width with rand height and width

		var xPos = (canvas.width);
		var yPos = canvas.height - 40;
		var w = 20;
		var h = 50;

		document.addEventListener("keydown", keyDownHandler, false);
		document.addEventListener("keyup", keyUpHandler, false);


		function keyDownHandler(e) {
		    if(e.key == "Right" || e.key == "ArrowRight") {
		        rightPressed = true;
		    }
		    else if(e.key == "Left" || e.key == "ArrowLeft") {
		        leftPressed = true;
		    }
		    else if (e.key == "Up" || e.key == "ArrowUp")
		    {
		    	upPressed = true;
		    }
		}

		function keyUpHandler(e) {
		    if(e.key == "Right" || e.key == "ArrowRight") {
		        rightPressed = false;
		    }
		    else if(e.key == "Left" || e.key == "ArrowLeft") {
		        leftPressed = false;
		    }
		    else if (e.key == "Up" || e.key == "ArrowUp")
		    {
		    	upPressed = false;
		    }
		}
		function getRndInteger(min, max) 
		{
  			return Math.floor(Math.random() * (max - min + 1) ) + min;
		}

		function collisionDetection() {
			
		  for(var c=0; c<brickColumnCount; c++) {
		    for(var r=0; r<brickRowCount; r++) {
		      var b = bricks[c][r];
		      if(b.status == 1) {
		        if(x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
		          dy = -dy;
		          b.status = 0;
		          score++;
		          if(score == brickRowCount*brickColumnCount) {
		            alert("YOU WIN, CONGRATS!");
		            document.location.reload();
		          }
		        }
		      }
		    }
		  }
		}

		function drawBall() {
		  ctx.beginPath();
		  ctx.arc(canvas.width/2, y, ballRadius, 0, Math.PI*2);
		  ctx.fillStyle = "#0095DD";
		  ctx.fill();
		  ctx.closePath();
		}
		function drawPaddle() {
		  ctx.beginPath();
		  ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
		  ctx.fillStyle = "#0095DD";
		  ctx.fill();
		  ctx.closePath();
		}
		function drawBricks() {
		  for(var c=0; c<brickColumnCount; c++) {
		    for(var r=0; r<brickRowCount; r++) {
		      if(bricks[c][r].status == 1) {
		        var brickX = (r*(brickWidth+brickPadding))+brickOffsetLeft;
		        var brickY = ((c*(brickHeight+brickPadding))+brickOffsetTop);
		        bricks[c][r].x = brickX;
		        bricks[c][r].y = brickY;
		        
		        if (c !=2 && c!=3 && c!=4 && r!=2 && r!=3 && r!=1)
		        {
		        bricks[c][r].status == 1;
		        ctx.beginPath();
		        ctx.rect(brickX, brickY, brickWidth, brickHeight);
		        ctx.fillStyle = "#0095DD";
		        ctx.fill();
		        ctx.closePath();
		        }
		        else
		        {
		        	//bricks[c][r].status == 0;
		        }
		        
		      }
		    }
		  }
		}
		function drawObstacle()
		{
			ctx.beginPath();
			xPos = xPos+dx
			var mx = canvas.width/2;
			//var yPos = 200;
			//var w = 50;
			//var h = 50;
		    ctx.rect(xPos, yPos, w, h);
		    ctx.fillStyle = "#0095DD";
		    ctx.fill();
		    ctx.closePath();

		    //if(x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight)
		    if( (mx > xPos) && (mx < xPos+w) && (y > yPos) && (y < yPos+h)) 
		    {
		        //dy = -dy;
		          //b.status = 0;
		        //score++;
		        alert("GAME OVER");
		        xPos = canvas.width;
		        document.location.reload();
		          //if(score == brickRowCount*brickColumnCount) {
		            //alert("YOU WIN, CONGRATS!");
		            //document.location.reload();
		     }
		}
		function drawScore() {
		  ctx.font = "16px Arial";
		  ctx.fillStyle = "#0095DD";
		  ctx.fillText("Score: "+score, 8, 20);
		}
		function drawLives() {
		  ctx.font = "16px Arial";
		  ctx.fillStyle = "#0095DD";
		  ctx.fillText("Lives: "+lives, canvas.width-65, 20);
		}

		function draw() {
		  ctx.clearRect(0, 0, canvas.width, canvas.height);
		 // drawBricks();
		  drawBall();
		  drawPaddle();
		  drawScore();
		  drawLives();
		  drawObstacle();
		 // collisionDetection();
		  

		  /*if(x + dx > canvas.width-ballRadius || x + dx < ballRadius) {
		    dx = -dx;
		  }*/
		 /* if(y + dy < ballRadius) {
		    dy = -dy;
		  }*/
		  if(y + dy > canvas.height-ballRadius) {
		    //if(x > paddleX && x < paddleX + paddleWidth) {
		      inAir = false;
		      dy = 0;
		     //dy = -dy;
		    //}
		   
		    /*else {
		      lives--;
		      if(!lives) {
		        alert("GAME OVER");
		        document.location.reload();
		      }*/
		      /*
		      else {
		        x = canvas.width/2;
		        y = canvas.height-30;
		        dx = 3;
		        dy = -3;
		        paddleX = (canvas.width-paddleWidth)/2;
		      }*/
		    //}
		  }

		/* if(rightPressed && paddleX < canvas.width-paddleWidth) {
		    paddleX += 7;
		  }
		  else if(leftPressed && paddleX > 0) {
		    paddleX -= 7;
		  }*/
		  if (inAir)
		  {
		   dy += gravForce;
		  }
		  //if(leftPressed && (inAir == false))
		  if(upPressed && (inAir == false))
		  {
		  	//dx = 3;
		  	dy = -20;
		    inAir = true;
		  }
			
		  x += dx;
		  y += dy;
		  requestAnimationFrame(draw);
		}

		draw();
	</script>
</body>
</html>